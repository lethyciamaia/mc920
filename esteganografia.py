# -*- coding: utf-8 -*-
"""Esteganografia.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Dk5ny_6pT7AGgfBDX931n7kvIOSbBAfG

# **MC920 - 2s2022**
###Trabalho 1: Esteganografia
### Lethycia Maia de Souza - RA 256477

**INTRODUÇÃO:**

A esteganografia, do grego "estegano", que significa “esconder ou mascarar” e grafia, que significa “escrita”, baseia-se em ocultar informações em uma imagem.

Para isso, existem diversas técnicas de alteração dessa imagem com a mensagem que deseja-se esconder, seja ela um texto, uma imagem ou em outros formatos de informações existentes. A técnica explorada neste trabalho foi a de modificação dos bits menos significativos que compõe cada pixel da imagem, sendo a mensagem armazenada nesses bits.

**OBJETIVO:**

Este trabalho teve como objetivo implementar um algoritmo de esteganografia em imagens digitais através da técnica de alteração dos bits menos significativos da imagem.

**EXECUÇÃO DO CÓDIGO:**

O trabalho foi desenvolvido no GOOGLE COLAB usando Python 3. As imagens utilizadas foram retiradas da [página](https://www.ic.unicamp.br/~helio/imagens_coloridas/) do Professor Doutor Hélio Pedrini e se encontram no neste notebook na pasta "images". Os textos que foram utilizados como informações ocultas nas imagens estão na pasta "texts".
- É necessário ter as bibliotecas do Python Pillow, IPython.display, numpy e bitarray.

**SOLUÇÃO:**

A imagem de entrada, que recebe a informação ocultada, tem o formato PNG (Portable Network Graphics), formato de arquivo extensível para armazenamento sem perdas, portátil e bem compactado. Uma imagem pode ser representada por uma matriz com m colunas e n linhas em que cada elemento a[i,j] é chamado de Pixel.
Um pixel é a menor unidade que compõe uma imagem, cada um deles com 3 bytes, um para representar cada uma das 3 cores elementares: Vermelho, Verde e Azul, com suas intensidades variando de 0 a 255. Para esse sistema se dá o nome de modelo RGB.

O programa codifica uma mensagem de texto, convertendo cada caractere da mensagem para array de bits correspondente em código ASCII. Então ele percorre os pixels da imagem e colocando os bits da mensagem nos bits menos significativos de cada canal de cor RGB.

Na solução apresentada, ocorre a mudança apenas nos bits menos significativos, porém, para aumentar a capacidade de cada imagem, poderia (após preencher todos os bits mais a direita) preencher outros mais à esquerda, sem que afete tanto o resultado final. Porém isso não foi implementado.

Para saber se há uma mensagem na imagem, foi colocada uma label "#IN" no inicio de cada mensagem e uma label "#FIM" ao término da mensagem, para facilitar o processo de decodificação.

**CÓDIGO:**

Primeiro, foi instalada a biblioteca do Python bitarray e foram importadas outras para desenvolver a solução.
"""

!pip install bitarray

from PIL import Image
from IPython.display import display
import numpy as np
import bitarray

"""A função *str2Binary* recebe como parâmetro a mensagem como string e devolve uma lista de bits que corresponde à representação binária da mensagem em código ASCII.

"""

def str2Binary(message):
  encoded = message.encode('ascii')
  ba = bitarray.bitarray()
  ba.frombytes(encoded)
  return [int(i) for i in ba]

"""Para a função *encode*, recebe como parâmetro a imagem e a mensagem que se deseja ocultar.

Adiciona-se um padrão de inicio "#IN" e de término da mensagem "#FIM". Ambos foram escolhidos de acordo com uma aproximação com a liguagem humana, com o símbolo de '#' apenas para não impedir mensagens com palavras que tenham "FIM" e "IN" nelas.
Para aumentar a gama de mensagens possiveis, poderia-se utilizar sequências de caracteres mais incomuns ou até adicionar no início o tamanho da mensagem em bytes.

Quando a mensagem é maior que a capacidade da imagem, é lançado um ValueError informando o problema.

Então, após garantir que a mensagem cabe na imagem, os pixels são percorridos da esquerda para a direita, de cima para baixo, e o bit menos significativo de cada canal de cor (Red, Green ou Blue) é trocado por um bit da mensagem, que é percorrido da esquerda para a direita.

Após isso a imagem é salva e é retornada pela função.
"""

def encode(image, message):
  pixels = image.load()
  width, height = image.size
  b_message = str2Binary("#IN" + message + "#FIM")

  #validate
  n_bytes = width * height * 3//8
  if n_bytes + 8 < len(message):
      raise ValueError("Informação não suportada pela imagem")

  message_index = 0
  for h in range(0, height):
    for w in range(0, width):
      r, g, b = [bin(k) for k in pixels[w, h]]
      newR, newG, newB = [k for k in pixels[w, h]]

      # Red
      if len(b_message) > message_index:
          newR = int(r[:-1] + str(b_message[message_index]), 2)
          message_index += 1
      # Green
      if len(b_message) > message_index:
          newG = int(g[:-1] + str(b_message[message_index]), 2)
          message_index += 1
      # Blue
      if len(b_message) > message_index:
          newB = int(b[:-1] + str(b_message[message_index]), 2)
          message_index += 1

      if len(b_message) < message_index:
            break
      pixels[w, h] = (newR, newG, newB)

  image.save("images/encoded.png")
  return image

"""Para a função *decode*, recebe apenas uma imagem para checarmos se está codificada ou não. Caso esteja, ela devolve a mensagem decodificada, caso não, ela cria uma exceção informando.

Para isso, assim como na função *encode*, ela percorre os pixels da imagem, da esquerda para a direita, pegando sempre os bits menos significativos dos canais de cores RGB.
Sabe-se que toda mensagem inicia com a sequência "#IN" que possui 3 bytes de 8 bits cada. Portanto, ao decodificar 3 bytes, 24 bits, a função checa se a mensagem decodificada é igual a "#IN". Se for, ela continua decodificando os próximos bits da mensagem, se não, informa que não existe mensagem oculta.

Ao decodificar todos os bits dos pixels menos negativos, a função separa os bits de 8 em 8 numa lista de bytes.
Após  isso, ela transforma esses grupos de bits em um caracter de acordo com a tabela ASCII até encontrar o padrão "#FIM" que determina o término da mensagem.
Por fim, a função retorna a mensagem a partir do 4º caracter até a posição n-5, n sendo igual ao tamanho da mensagem, desconsiderando os padrões de inicio e fim.  

Nota-se que a função precisa passar por todos os pixels da imagem para poder decodificá-la. Uma forma de otimizar seria ao invés de usar padrões no inicio e fim, colocar o tamanho da mensagem no início dela, como já foi citado anteriormente.
"""

def decode(image):
  pixels = image.load()
  width, height = image.size

  b_decoded = ""
  ini = False
  for h in range(0, height):
      for w in range(0, width):
          r, g, b = [bin(k) for k in pixels[w, h]]

          b_decoded += r[-1]
          b_decoded += g[-1]
          b_decoded += b[-1]

          if len(b_decoded) == 24 and not ini:
              ini = True
              bytes1 = [b_decoded[i: i+8] for i in range(0, len(b_decoded), 8)]
              decoded = ""
              for byte in bytes1:
                  decoded += chr(int(byte, 2))

              if decoded != "#IN":
                  raise Exception("Essa imagem não possui mensagem")

  bytesA = [b_decoded[i: i+8] for i in range(0, len(b_decoded), 8)]
  decoded = ""
  for byte in bytesA:
      decoded += chr(int(byte, 2))
      if decoded[-4:] == "#FIM":
          break

  return decoded[3:-4]

"""Cópias das imagens para que não sejam mexidas nas originais."""

img1 = Image.open('images/baboon.png')
img1.save("images/lsb_baboon.png")

img2 = Image.open('images/watch.png')
img2.save("images/lsb_watch.png")

"""**TESTES DE EXECUÇÃO:**

Primeiramente, testou-se o arquivo "frevo4.txt" na imagem "baboon.png".
Essa é uma imagem de 512x512, logo ela suporta até 98304 bytes de mensagem usando apenas os bits menos significativos. O texto possui 126712 caracteres, ou seja, mais do que a imagem consegue esconder. Portanto, nesse teste, será gerado um ValueError.
"""

m = open('texts/frevo4.txt', 'r')
message = m.read()
img_c = Image.open("images/lsb_baboon.png")

img_encoded = encode(img_c, message)

"""Para esse segundo texte, foi usado o mesmo arquivo de texto, porém numa imagem com mais pixels 1024×768. Portanto, a codificação deverá acontecer."""

m = open('texts/frevo4.txt', 'r')
message = m.read()
img2_c = Image.open("images/lsb_watch.png")

img2_encoded = encode(img2_c, message)
display(img2_encoded)

"""Pode-se notar que essa imagem é extramamente parecida com a sua original abaixo e a mensagem passa completamente despercebida a olho nu."""

display(Image.open("images/watch.png"))

"""Enfim, o terceiro teste, onde decodificamos a mensagem da imagem codificada no teste anterior."""

decoded_message = decode(img2_encoded)
print(decoded_message)

"""Pode-se perceber, ao analisar o arquivo "frevo4.txt" que a mensagem decodificada correspode ao texto contido nesse arquivo que foi usado anteriormente para codificar na imagem do relógio. Esse texto corresponde a algumas letras de musicas tradicionais no carnaval de Recife e Olinda."""